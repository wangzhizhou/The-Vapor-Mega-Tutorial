# Async

`Async`是`Vapor 3`的重要特性，但这个特性刚开始容易令人困惑。

假设一个服务器只有一个线程处理客户请求，四个客户端请求顺序发起：

- 第一个请求需要从服务器获取股票报价，但股票报价需要服务器从另外的服务器获取后才能返回给客户端。

- 第二个请求获取CSS样式表，这个样式表可以从服务器自己的存储器中直接获取。

- 第三个请求需要服务器从数据库中查询用户信息，返回给客户端

- 第四个请求获取HTML内容，这些HTML内容也可以在服务器自己的存储器中直接获取。

如果用一个同步服务器处理这四个请求，因为是单线程，所有当第一个请求发起后，第二个请求需要在第一个请求处理完成后才能被处理到，所以四个请求是顺序执行，前一个处理完成才能处理后一个。

如果用一个异步服务器处理这四个请求，同样也是单线程，当第一个请求发起后，服务器初始化一个调用去处理请求不能马上处理完成返回结果，此时就会把第一个请求先放在一边，马上去处理第二个请求。当被放在一边的请求处理完成后会恢复线程执行，把结果返回给客户端。

虽然服务器可以有多个线程处理请求，但是服务器同时开启的线程数量是有上限的，在多个线程间切换环境是很耗费资源的操作，并且数据在多线程间访问时处理不当很容易发生错误。多线程服务器使用线程池的方式，效率也不高。

以异步的方式处理请求，把请求放在一边这种操作可以通过promise的方式把处理过程封装起来，一旦处理完成就返回给客户端。把一个不确定啥时候返回的结果封装成一个Future结构。

假设有一个人函数是这样的：

```swift
func getAllUsers() -> [User] {
    // do some database queries
}
```
在异步环境下，这个函数返回时，可能数据库的查询操作还没有完成，所以是不能正常工作的。这种情况下，只知道函数会返回一个数组[User]，却不清楚返回的具体时刻，所以需要改造一下返回类型，用Future<Type>这个范型结构承诺在将来的某个时刻返回对应的类型的数据。

```swift 
func getAllUsers() -> Future<[User]> {
    // do some database queries
}
```

使用Future可能一开始会有点困惑，因为这个概念还不是很熟悉，不过使用一段时间就会适应，毕竟在Vapor中会有大量场景使用它。

和Future搭配使用的操作有以下几种：

- flatMap：CollectionType<ElemType> -> AnotherElemType
- map: CollectionType<ElemType> -> CollectionType<AnotherElemType>
- transform: 与map类似，不处理具体元素，直接变换为指定值
- flatten: 等所有Future都返回时执行
- do/catch: 用来捕获错误，但不是恢复错误
- catchMap/catchFlatMap: 捕获并修复错误
- always: 不管结果如果总会执行
- wait: 不能在主线程上使用

在Vapor中一个Request就是一个Worker，相当于一个线程。

全局操作支持最多五个Future结果返回后执行。

对Future可以链式操作，用来避免过度嵌套。

!!! note "SwiftNIO"
    是苹果的一个开源跨平台异步网络库，它用来管理连接和处理数据传输，管理着事件循环(EventLoop)，每一个事件循环对应一个线程。

    如果一个线程写入一个变量的同时有另外一个线程同时的对这个变量进行读或者写操作，那么就会产生竞争关系，有可能会使你的应用发生崩溃。传统的处理方式是给多个线程同时访问的变量各自加一把锁来使对变量的访问变的有序，从而消除竞争关系。线程在访问一个变量前先给这个变量上锁，表示此刻该变量正在使用，其它线程不能访问，等访问完成后对该变量解锁，以示其它线程可以继续对其进行访问。这是一种解决办法，但是存在缺点，就是使用起来很复杂，同时也会影响到程序的执行效率。

    另一种思路是把对同一个变量的访问都放在同一个线程里来进行。但这就要求这个处理读写操作的线程要能够把读写的结果返回给发起读写请求的线程中去。其实每一个事件循环(EventLoop)都可以看作是一个线程。 如果变量的读写操作所在的线程把读写结果返回给没有发起读写请求的其它线程，那么SwiftNIO就会用崩溃来避免程序发生不确定问题。要把读写操作的结果返回给发起读写请求的相关线程中去的功能就需要用到`Future`和`Promise`这两个概念了。

    `Future`是用来描述目前还不存在，但未来会存在的信息的一种数据结构。写异步代码时用`Future`来表示一个处理结果是成功还是失败，这两种结果确定会发生在未来，但是目前不知道会是哪一种。但是如果不知道未来结果到底是什么样子(可能成功，可能失败，也可能是其它的)，那就需要创建`Promise`了。

    `Promise`和`Future`都必须在事件循环(EventLoop)中创建，`Future`会被返回给产生它的事件循环中，一次只能代表一个结果，要么成功，要么失败，都算是处理完成状态。然后`Promise`创建时一定是完成状态的。