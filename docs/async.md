# Async

`Async`是`Vapor 3`的重要特性，但这个特性刚开始容易令人困惑。

假设一个服务器只有一个线程处理客户请求，四个客户端请求顺序发起：

- 第一个请求需要从服务器获取股票报价，但股票报价需要服务器从另外的服务器获取后才能返回给客户端。

- 第二个请求获取CSS样式表，这个样式表可以从服务器自己的存储器中直接获取。

- 第三个请求需要服务器从数据库中查询用户信息，返回给客户端

- 第四个请求获取HTML内容，这些HTML内容也可以在服务器自己的存储器中直接获取。

如果用一个同步服务器处理这四个请求，因为是单线程，所有当第一个请求发起后，第二个请求需要在第一个请求处理完成后才能被处理到，所以四个请求是顺序执行，前一个处理完成才能处理后一个。

如果用一个异步服务器处理这四个请求，同样也是单线程，当第一个请求发起后，服务器初始化一个调用去处理请求不能马上处理完成返回结果，此时就会把第一个请求先放在一边，马上去处理第二个请求。当被放在一边的请求处理完成后会恢复线程执行，把结果返回给客户端。

虽然服务器可以有多个线程处理请求，但是服务器同时开启的线程数量是有上限的，在多个线程间切换环境是很耗费资源的操作，并且数据在多线程间访问时处理不当很容易发生错误。多线程服务器使用线程池的方式，效率也不高。

以异步的方式处理请求，把请求放在一边这种操作可以通过promise的方式把处理过程封装起来，一旦处理完成就返回给客户端。把一个不确定啥时候返回的结果封装成一个Future结构。

假设有一个人函数是这样的：

```swift
func getAllUsers() -> [User] {
    // do some database queries
}
```
在异步环境下，这个函数返回时，可能数据库的查询操作还没有完成，所以是不能正常工作的。这种情况下，只知道函数会返回一个数组[User]，却不清楚返回的具体时刻，所以需要改造一下返回类型，用Future<Type>这个范型结构承诺在将来的某个时刻返回对应的类型的数据。

```swift 
func getAllUsers() -> Future<[User]> {
    // do some database queries
}
```

使用Future可能一开始会有点困惑，因为这个概念还不是很熟悉，不过使用一段时间就会适应，毕竟在Vapor中会有大量场景使用它。

和Future搭配使用的操作有以下几种：

- flatMap：CollectionType<ElemType> -> AnotherElemType
- map: CollectionType<ElemType> -> CollectionType<AnotherElemType>
- transform: 与map类似，不处理具体元素，直接变换为指定值
- flatten: 等所有Future都返回时执行
- do/catch: 用来捕获错误，但不是恢复错误
- catchMap/catchFlatMap: 捕获并修复错误
- always: 不管结果如果总会执行
- wait: 不能在主线程上使用

在Vapor中一个Request就是一个Worker，相当于一个线程。

全局操作支持最多五个Future结果返回后执行。

对Future可以链式操作，用来避免过度嵌套。

!!! note "SwiftNIO"
    是一个开源跨平台异步网络库，它用来管理连接和处理数据传输，管理着事件循环，每一个事件循环对应一个线程。